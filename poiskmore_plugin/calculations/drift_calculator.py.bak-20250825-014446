# -*- coding: utf-8 -*-
"""
Drift calculator for Poisk-More plugin (pure Python, no QGIS deps).
Computes Total Water Current (TWC) from wind/current inputs and applies drift
to get a datum position.

Author: GPT-5 Pro
License: GPLv3 (follow project)
"""

from dataclasses import dataclass
from math import sin, cos, atan2, radians, degrees, sqrt, isfinite

# --- Helpers -----------------------------------------------------------------

def _norm_course(deg: float) -> float:
    d = deg % 360.0
    return d if d >= 0 else d + 360.0

def _knots_to_kmh(kn: float) -> float:
    return kn * 1.852

def _kmh_to_knots(kmh: float) -> float:
    return kmh / 1.852

def _nm_to_km(nm: float) -> float:
    return nm * 1.852

def _km_to_nm(km: float) -> float:
    return km / 1.852

def _bearing_to_vector(course_deg: float, speed_knots: float) -> tuple:
    """Return vector (vx, vy) in knots for course (bearing from North, CW)."""
    # Convert to mathematical angle (0° = East, CCW positive)
    # For navigation: 0° = North, 90° = East.
    theta = radians(90.0 - course_deg)
    vx = speed_knots * cos(theta)
    vy = speed_knots * sin(theta)
    return vx, vy

def _vector_to_bearing(vx: float, vy: float) -> tuple:
    """Convert XY vector (knots) back to (course_deg, speed_knots)."""
    speed = sqrt(vx * vx + vy * vy)
    # Compute navigation bearing: 0° = North, CW
    theta = degrees(atan2(vy, vx))  # math angle (0=East, CCW+)
    course = _norm_course(90.0 - theta)
    return course, speed

def _dms_lat(lat: float) -> str:
    hemi = 'N' if lat >= 0 else 'S'
    lat = abs(lat)
    d = int(lat)
    m = (lat - d) * 60
    return f"{d:02d}°{m:06.3f}'{hemi}"

def _dms_lon(lon: float) -> str:
    hemi = 'E' if lon >= 0 else 'W'
    lon = abs(lon)
    d = int(lon)
    m = (lon - d) * 60
    return f"{d:03d}°{m:06.3f}'{hemi}"

def format_latlon(lat: float, lon: float) -> str:
    return f"{_dms_lat(lat)} { _dms_lon(lon) }"

# --- Data classes ------------------------------------------------------------

@dataclass
class DriftVector:
    course_deg: float  # navigation bearing (0..359)
    speed_knots: float

@dataclass
class Wind:
    dir_deg: float     # from where wind blows (meteo). For set we use TO direction.
    speed_knots: float

@dataclass
class SurfaceCurrent:
    course_deg: float  # where current flows TO (navigation)
    speed_knots: float

# --- Core calculator ---------------------------------------------------------

class DriftCalculator:
    """
    Simplified drift model:
    - Wind set is approximated as 3% of true wind speed (direction TO = wind_dir + 180)
    - Surface current is added vectorially (if provided)
    - Datum is obtained by applying TWC over time (hours) to start lat/lon
    Latitude/longitude are treated with a simple rhumb approximation:
      1 minute of latitude = 1 NM; longitude scaled by cos(lat)
    """

    def estimate_twc(self, wind: Wind = None, cur: SurfaceCurrent = None) -> DriftVector:
        vx_total = 0.0
        vy_total = 0.0

        if wind is not None and isfinite(wind.speed_knots):
            # Convert meteo "FROM" to navigation "TO"
            wind_to_course = _norm_course(wind.dir_deg + 180.0)
            wind_set_knots = 0.03 * wind.speed_knots  # 3% rule (coarse)
            vx, vy = _bearing_to_vector(wind_to_course, wind_set_knots)
            vx_total += vx
            vy_total += vy

        if cur is not None and isfinite(cur.speed_knots):
            vx, vy = _bearing_to_vector(cur.course_deg, cur.speed_knots)
            vx_total += vx
            vy_total += vy

        course, speed = _vector_to_bearing(vx_total, vy_total)
        return DriftVector(course_deg=course, speed_knots=speed)

    def apply_drift(self, lat_deg: float, lon_deg: float, hours: float, twc: DriftVector) -> tuple:
        """
        Apply drift along TWC for 'hours' and return (lat2, lon2).
        """
        if hours <= 0.0 or not isfinite(hours) or twc.speed_knots <= 0.0:
            return lat_deg, lon_deg

        # Distance in NM
        distance_nm = twc.speed_knots * hours

        # Convert to delta in degrees using rhumb-line small displacements
        # 1 degree of latitude = 60 NM
        dlat_deg = (distance_nm * cos(radians(twc.course_deg))) / 60.0
        # 1 degree of longitude = 60 * cos(lat) NM
        lon_scale = 60.0 * max(1e-6, cos(radians(lat_deg)))
        dlon_deg = (distance_nm * sin(radians(twc.course_deg))) / lon_scale

        return lat_deg + dlat_deg, lon_deg + dlon_deg

    def compute_datum(self,
                      lat_deg: float,
                      lon_deg: float,
                      hours: float,
                      wind: Wind = None,
                      cur: SurfaceCurrent = None) -> tuple:
        """
        Convenience wrapper: compute TWC and datum.
        Returns (twc_vector, lat2, lon2).
        """
        twc = self.estimate_twc(wind=wind, cur=cur)
        lat2, lon2 = self.apply_drift(lat_deg, lon_deg, hours, twc)
        return twc, lat2, lon2
